"use strict";

exports.__esModule = true;
exports.useTooltip = useTooltip;

var _hooks = require("@chakra-ui/hooks");

var _popper = require("@chakra-ui/popper");

var _utils = require("@chakra-ui/utils");

var _react = require("react");

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function useTooltip(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props,
      _props$openDelay = _props.openDelay,
      openDelay = _props$openDelay === void 0 ? 0 : _props$openDelay,
      _props$closeDelay = _props.closeDelay,
      closeDelay = _props$closeDelay === void 0 ? 0 : _props$closeDelay,
      _props$closeOnClick = _props.closeOnClick,
      closeOnClick = _props$closeOnClick === void 0 ? true : _props$closeOnClick,
      closeOnMouseDown = _props.closeOnMouseDown,
      onOpenProp = _props.onOpen,
      onCloseProp = _props.onClose,
      placement = _props.placement,
      id = _props.id,
      isOpenProp = _props.isOpen,
      defaultIsOpen = _props.defaultIsOpen,
      _props$arrowSize = _props.arrowSize,
      arrowSize = _props$arrowSize === void 0 ? 10 : _props$arrowSize,
      modifiers = _props.modifiers,
      isDisabled = _props.isDisabled,
      htmlProps = _objectWithoutPropertiesLoose(_props, ["openDelay", "closeDelay", "closeOnClick", "closeOnMouseDown", "onOpen", "onClose", "placement", "id", "isOpen", "defaultIsOpen", "arrowSize", "modifiers", "isDisabled"]);

  var _useDisclosure = (0, _hooks.useDisclosure)({
    isOpen: isOpenProp,
    defaultIsOpen: defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  }),
      isOpen = _useDisclosure.isOpen,
      onOpen = _useDisclosure.onOpen,
      onClose = _useDisclosure.onClose;

  var popper = (0, _popper.usePopper)({
    forceUpdate: isOpen,
    placement: placement,
    arrowSize: arrowSize,
    modifiers: modifiers
  });
  var tooltipId = (0, _hooks.useId)(id, "tooltip");
  var ref = (0, _react.useRef)(null);
  var triggerRef = (0, _utils.mergeRefs)(ref, popper.reference.ref);
  var enterTimeout = (0, _react.useRef)();
  var exitTimeout = (0, _react.useRef)();
  var openWithDelay = (0, _react.useCallback)(function () {
    if (!isDisabled) {
      enterTimeout.current = window.setTimeout(onOpen, openDelay);
    }
  }, [isDisabled, onOpen, openDelay]);
  var closeWithDelay = (0, _react.useCallback)(function () {
    if (enterTimeout.current) {
      clearTimeout(enterTimeout.current);
    }

    exitTimeout.current = window.setTimeout(onClose, closeDelay);
  }, [closeDelay, onClose]);
  var onClick = (0, _react.useCallback)(function () {
    if (closeOnClick) {
      closeWithDelay();
    }
  }, [closeOnClick, closeWithDelay]);
  var onMouseDown = (0, _react.useCallback)(function () {
    if (closeOnMouseDown) {
      closeWithDelay();
    }
  }, [closeOnMouseDown, closeWithDelay]);

  var onKeyDown = function onKeyDown(event) {
    if (isOpen && event.key === "Escape") {
      closeWithDelay();
    }
  };

  (0, _hooks.useEventListener)("keydown", onKeyDown);
  (0, _react.useEffect)(function () {
    return function () {
      clearTimeout(enterTimeout.current);
      clearTimeout(exitTimeout.current);
    };
  }, []);
  var getTriggerProps = (0, _react.useCallback)(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    return _extends({}, props, {
      ref: (0, _utils.mergeRefs)(ref, triggerRef),
      onMouseLeave: (0, _utils.callAllHandlers)(props.onMouseLeave, closeWithDelay),
      onMouseEnter: (0, _utils.callAllHandlers)(props.onMouseEnter, openWithDelay),
      onClick: (0, _utils.callAllHandlers)(props.onClick, onClick),
      onMouseDown: (0, _utils.callAllHandlers)(props.onMouseDown, onMouseDown),
      onFocus: (0, _utils.callAllHandlers)(props.onFocus, openWithDelay),
      onBlur: (0, _utils.callAllHandlers)(props.onBlur, closeWithDelay),
      "aria-describedby": isOpen ? tooltipId : undefined
    });
  }, [closeWithDelay, isOpen, onClick, onMouseDown, openWithDelay, tooltipId, triggerRef]);
  var getTooltipProps = (0, _react.useCallback)(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    return _extends({}, htmlProps, props, {
      id: tooltipId,
      role: "tooltip",
      ref: (0, _utils.mergeRefs)(ref, popper.popper.ref),
      style: _extends({}, props.style, popper.popper.style)
    });
  }, [htmlProps, popper.popper.ref, popper.popper.style, tooltipId]);
  var getArrowProps = (0, _react.useCallback)(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    return _extends({}, props, {
      ref: (0, _utils.mergeRefs)(ref, popper.arrow.ref),
      style: _extends({}, props.style, popper.arrow.style)
    });
  }, [popper.arrow.ref, popper.arrow.style]);
  return {
    isOpen: isOpen,
    show: openWithDelay,
    hide: closeWithDelay,
    placement: popper.placement,
    getTriggerProps: getTriggerProps,
    getTooltipProps: getTooltipProps,
    getArrowProps: getArrowProps
  };
}
