"use strict";

exports.__esModule = true;
exports.useAccordion = useAccordion;
exports.useAccordionItem = useAccordionItem;
exports.useAccordionContext = exports.AccordionProvider = void 0;

var _descendant = require("@chakra-ui/descendant");

var _hooks = require("@chakra-ui/hooks");

var _utils = require("@chakra-ui/utils");

var _react = require("react");

var warn = _interopRequireWildcard(require("./warning"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * useAccordion hook provides all the state and focus management logic
 * for accordion items.
 */
function useAccordion(props) {
  var onChange = props.onChange,
      defaultIndex = props.defaultIndex,
      indexProp = props.index,
      allowMultiple = props.allowMultiple,
      allowToggle = props.allowToggle,
      htmlProps = _objectWithoutPropertiesLoose(props, ["onChange", "defaultIndex", "index", "allowMultiple", "allowToggle"]); // validate the props and `warn` if used incorrectly


  warn.allowMultiple(props);
  warn.allowMultipleAndAllowToggle(props);
  /**
   * Think of this as the register to each accordion item.
   * We used to manage focus between accordion item buttons.
   *
   * Every accordion item, registers their button refs in this context
   */

  var domContext = (0, _descendant.useDescendants)();
  /**
   * This state is used to track the index focused accordion
   * button when click on the button, tab on the button, or
   * use the down/up arrow to navigate.
   */

  var _useState = (0, _react.useState)(-1),
      focusedIndex = _useState[0],
      setFocusedIndex = _useState[1];
  /**
   * Hook that manages the controlled and un-controlled state
   * for the accordion.
   */


  var _useControllableState = (0, _hooks.useControllableState)({
    value: indexProp,
    defaultValue: function defaultValue() {
      if (allowMultiple) {
        return defaultIndex != null ? defaultIndex : [];
      } else {
        return defaultIndex != null ? defaultIndex : -1;
      }
    },
    onChange: onChange,
    propsMap: {
      value: "index",
      defaultValue: "defaultIndex"
    }
  }),
      index = _useControllableState[0],
      setIndex = _useControllableState[1];
  /**
   * Gets the `isOpen` and `onChange` props for a child accordion item based on
   * the child's index.
   *
   * @param idx {number} The index of the child accordion item
   */


  var getItemProps = function getItemProps(idx) {
    var isOpen = (0, _utils.isArray)(index) ? index.includes(idx) : index === idx;

    var onChange = function onChange(isOpen) {
      if (allowMultiple && (0, _utils.isArray)(index)) {
        var nextState = isOpen ? (0, _utils.addItem)(index, idx) : (0, _utils.removeItem)(index, idx);
        setIndex(nextState);
      } else {
        if (isOpen) {
          setIndex(idx);
        } else if (allowToggle) {
          setIndex(-1);
        }
      }
    };

    return {
      isOpen: isOpen,
      onChange: onChange
    };
  };

  return {
    htmlProps: htmlProps,
    getItemProps: getItemProps,
    focusedIndex: focusedIndex,
    setFocusedIndex: setFocusedIndex,
    domContext: domContext
  };
}

var _createContext = (0, _utils.createContext)({
  name: "AccordionContext",
  errorMessage: "useAccordionContext: `context` is undefined. Seems you forgot to wrap the accordion components in `<Accordion />`"
}),
    AccordionProvider = _createContext[0],
    useAccordionContext = _createContext[1];

exports.useAccordionContext = useAccordionContext;
exports.AccordionProvider = AccordionProvider;

/**
 * useAccordionItem
 *
 * React hook that provides the open/close functionality
 * for an accordion item and it's children
 */
function useAccordionItem(props) {
  var isDisabled = props.isDisabled,
      isFocusable = props.isFocusable,
      id = props.id,
      htmlProps = _objectWithoutPropertiesLoose(props, ["isDisabled", "isFocusable", "id"]);

  var _useAccordionContext = useAccordionContext(),
      getItemProps = _useAccordionContext.getItemProps,
      domContext = _useAccordionContext.domContext,
      focusedIndex = _useAccordionContext.focusedIndex,
      setFocusedIndex = _useAccordionContext.setFocusedIndex;

  var descendants = domContext.descendants;
  var buttonRef = (0, _react.useRef)(null);
  /**
   * Generate unique ids for all accordion item components (button and panel)
   */

  var _useIds = (0, _hooks.useIds)(id, "accordion-button", "accordion-panel"),
      buttonId = _useIds[0],
      panelId = _useIds[1];

  warn.focusableNotDisabled(props);
  /**
   * Think of this as a way to register this accordion item
   * with it's parent `useAccordion`
   */

  var index = (0, _descendant.useDescendant)({
    element: buttonRef.current,
    context: domContext,
    disabled: isDisabled,
    focusable: isFocusable
  });

  var _getItemProps = getItemProps(index),
      isOpen = _getItemProps.isOpen,
      onChange = _getItemProps.onChange;

  var onOpen = function onOpen() {
    onChange == null ? void 0 : onChange(true);
  };

  var onClose = function onClose() {
    onChange == null ? void 0 : onChange(false);
  };

  var shouldFocus = index === focusedIndex;
  /**
   * Autofocus the accordion button when
   * the active index matched the accordion item's index
   */

  (0, _hooks.useFocusEffect)(buttonRef, {
    shouldFocus: shouldFocus
  });
  /**
   * Toggle the visibility of the accordion item
   */

  var onClick = (0, _react.useCallback)(function () {
    onChange == null ? void 0 : onChange(!isOpen);
    setFocusedIndex(index);
  }, [index, isOpen, onChange, setFocusedIndex]);
  /**
   * Manage keyboard navigation between accordion items.
   * `createOnKeyDown` makes it easy to write actions
   * for each event key
   */

  var onKeyDown = (0, _utils.createOnKeyDown)({
    keyMap: {
      ArrowDown: function ArrowDown() {
        var _nextAccordion$elemen;

        var nextIndex = (0, _utils.getNextIndex)(index, descendants.length);
        var nextAccordion = descendants[nextIndex];
        nextAccordion == null ? void 0 : (_nextAccordion$elemen = nextAccordion.element) == null ? void 0 : _nextAccordion$elemen.focus();
      },
      ArrowUp: function ArrowUp() {
        var _prevAccordion$elemen;

        var prevIndex = (0, _utils.getPrevIndex)(index, descendants.length);
        var prevAccordion = descendants[prevIndex];
        prevAccordion == null ? void 0 : (_prevAccordion$elemen = prevAccordion.element) == null ? void 0 : _prevAccordion$elemen.focus();
      },
      Home: function Home() {
        var _firstAccordion$eleme;

        var firstAccordion = descendants[0];
        firstAccordion == null ? void 0 : (_firstAccordion$eleme = firstAccordion.element) == null ? void 0 : _firstAccordion$eleme.focus();
      },
      End: function End() {
        var _lastAccordion$elemen;

        var lastAccordion = descendants[descendants.length - 1];
        lastAccordion == null ? void 0 : (_lastAccordion$elemen = lastAccordion.element) == null ? void 0 : _lastAccordion$elemen.focus();
      }
    }
  });
  /**
   * Since each accordion item's button still remains tabbable, let's
   * update the focusedIndex when it receives focus
   */

  var onFocus = (0, _react.useCallback)(function () {
    return setFocusedIndex(index);
  }, [index, setFocusedIndex]);
  var getButtonProps = (0, _react.useCallback)(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    return _extends({}, props, {
      ref: (0, _utils.mergeRefs)(buttonRef, ref),
      id: buttonId,
      disabled: !!isDisabled,
      "aria-expanded": !!isOpen,
      "aria-controls": panelId,
      onClick: (0, _utils.callAllHandlers)(props.onClick, onClick),
      onFocus: (0, _utils.callAllHandlers)(props.onFocus, onFocus),
      onKeyDown: (0, _utils.callAllHandlers)(props.onKeyDown, onKeyDown)
    });
  }, [buttonId, isDisabled, isOpen, onClick, onFocus, onKeyDown, panelId]);
  var getPanelProps = (0, _react.useCallback)(function (props, ref) {
    if (props === void 0) {
      props = {};
    }

    if (ref === void 0) {
      ref = null;
    }

    return _extends({}, props, {
      ref: ref,
      role: "region",
      id: panelId,
      "aria-labelledby": buttonId,
      hidden: !isOpen
    });
  }, [buttonId, isOpen, panelId]);
  return {
    isOpen: isOpen,
    isDisabled: isDisabled,
    isFocusable: isFocusable,
    onOpen: onOpen,
    onClose: onClose,
    getButtonProps: getButtonProps,
    getPanelProps: getPanelProps,
    htmlProps: htmlProps
  };
}
