"use strict";

exports.__esModule = true;
exports.omit = omit;
exports.pick = pick;
exports.split = split;
exports.get = get;
exports.getWithDefault = getWithDefault;
exports.filterUndefined = filterUndefined;
exports.objectKeys = void 0;

var _lodash = _interopRequireDefault(require("lodash.merge"));

exports.merge = _lodash["default"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function omit(object, keys) {
  var result = {};

  for (var key in object) {
    if (keys.includes(key)) continue;
    result[key] = object[key];
  }

  return result;
}

function pick(object, keys) {
  var result = {};

  for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
    var key = _step.value;

    if (key in object) {
      result[key] = object[key];
    }
  }

  return result;
}

function split(object, keys) {
  var picked = {};
  var omitted = {};

  for (var key in object) {
    if (keys.includes(key)) {
      picked[key] = object[key];
    } else {
      omitted[key] = object[key];
    }
  }

  return [picked, omitted];
}
/**
 * Get value from a deeply nested object using a string path
 * @param obj - the object
 * @param path - the string path
 * @param def  - the fallback value
 */


function get(obj, path, fallback, index) {
  var _path$split, _path;

  //@ts-ignore
  path = (_path$split = (_path = path) == null ? void 0 : _path.split == null ? void 0 : _path.split(".")) != null ? _path$split : [path];

  for (index = 0; index < path.length; index++) {
    obj = obj ? obj[path[index]] : undefined;
  }

  return obj === undefined ? fallback : obj;
}
/**
 * Get value from deeply nested object, based on path
 * It returns the path value if not found in object
 *
 * @param path - the string path or value
 * @param scale - the string path or value
 */


function getWithDefault(path, scale) {
  return get(scale, path, path);
}

function filterUndefined(object) {
  var result = _extends({}, object);

  for (var key in result) {
    if (result[key] == null) {
      delete result[key];
    }
  }

  return result;
}

var objectKeys = function objectKeys(obj) {
  return Object.keys(obj);
};

exports.objectKeys = objectKeys;
