"use strict";

exports.__esModule = true;
exports.useMenu = useMenu;
exports.useMenuList = useMenuList;
exports.useMenuButton = useMenuButton;
exports.useMenuItem = useMenuItem;
exports.useMenuOption = useMenuOption;
exports.useMenuOptionGroup = useMenuOptionGroup;
exports.useMenuState = useMenuState;
exports.useMenuContext = exports.MenuProvider = void 0;

var _clickable = require("@chakra-ui/clickable");

var _descendant = require("@chakra-ui/descendant");

var _hooks = require("@chakra-ui/hooks");

var _popper = require("@chakra-ui/popper");

var _utils = require("@chakra-ui/utils");

var _interactions = require("@react-aria/interactions");

var _react = require("react");

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _createContext = (0, _utils.createContext)({
  strict: false,
  name: "MenuContext"
}),
    MenuProvider = _createContext[0],
    useMenuContext = _createContext[1];

exports.useMenuContext = useMenuContext;
exports.MenuProvider = MenuProvider;

/**
 * React Hook to manage a menu
 *
 * It provides the logic and will be used with react context
 * to propagate it's return value to all children
 */
function useMenu(props) {
  var id = props.id,
      _props$closeOnSelect = props.closeOnSelect,
      closeOnSelect = _props$closeOnSelect === void 0 ? true : _props$closeOnSelect,
      _props$closeOnBlur = props.closeOnBlur,
      closeOnBlur = _props$closeOnBlur === void 0 ? true : _props$closeOnBlur,
      _props$autoSelect = props.autoSelect,
      autoSelect = _props$autoSelect === void 0 ? true : _props$autoSelect,
      _props$placement = props.placement,
      placementProp = _props$placement === void 0 ? "bottom-start" : _props$placement,
      gutter = props.gutter,
      _props$fixed = props.fixed,
      fixed = _props$fixed === void 0 ? true : _props$fixed,
      preventOverflow = props.preventOverflow,
      modifiers = props.modifiers,
      isLazy = props.isLazy;

  var _useDisclosure = (0, _hooks.useDisclosure)(props),
      isOpen = _useDisclosure.isOpen,
      onOpen = _useDisclosure.onOpen,
      onClose = _useDisclosure.onClose,
      onToggle = _useDisclosure.onToggle;
  /**
   * Prepare the reference to the menu and disclosure
   */


  var menuRef = (0, _react.useRef)(null);
  var buttonRef = (0, _react.useRef)(null);
  (0, _interactions.useInteractOutside)({
    ref: menuRef,
    onInteractOutside: function onInteractOutside(event) {
      var _buttonRef$current;

      if (closeOnBlur && !((_buttonRef$current = buttonRef.current) == null ? void 0 : _buttonRef$current.contains(event.target))) {
        onClose();
      }
    }
  });
  /**
   * Add some popper.js for dynamic positioning
   */

  var _usePopper = (0, _popper.usePopper)({
    placement: placementProp,
    fixed: fixed,
    forceUpdate: isOpen,
    gutter: gutter,
    preventOverflow: preventOverflow,
    modifiers: modifiers
  }),
      placement = _usePopper.placement,
      popper = _usePopper.popper,
      reference = _usePopper.reference;

  var _useState = (0, _react.useState)(-1),
      focusedIndex = _useState[0],
      setFocusedIndex = _useState[1];
  /**
   * Context to register all menu item nodes
   */


  var domContext = (0, _descendant.useDescendants)();
  /**
   * Focus the button when we close the menu
   */

  (0, _hooks.useUpdateEffect)(function () {
    if (!isOpen) {
      setFocusedIndex(-1);

      if (buttonRef.current) {
        (0, _utils.focus)(buttonRef.current, {
          preventScroll: true
        });
      }
    }
  }, [isOpen]);
  /**
   * Generate unique ids for menu's list and button
   */

  var _useIds = (0, _hooks.useIds)(id, "menu-button", "menu-list"),
      buttonId = _useIds[0],
      menuId = _useIds[1];

  return {
    domContext: domContext,
    popper: popper,
    placement: placement,
    reference: reference,
    buttonId: buttonId,
    menuId: menuId,
    orientation: "vertical",
    isOpen: isOpen,
    onToggle: onToggle,
    onOpen: onOpen,
    onClose: onClose,
    menuRef: menuRef,
    buttonRef: buttonRef,
    focusedIndex: focusedIndex,
    closeOnSelect: closeOnSelect,
    closeOnBlur: closeOnBlur,
    autoSelect: autoSelect,
    setFocusedIndex: setFocusedIndex,
    isLazy: isLazy
  };
}

function useMenuList(props) {
  var menu = useMenuContext();
  var focusedIndex = menu.focusedIndex,
      setFocusedIndex = menu.setFocusedIndex,
      menuRef = menu.menuRef,
      isOpen = menu.isOpen,
      onClose = menu.onClose,
      popper = menu.popper,
      menuId = menu.menuId,
      placement = menu.placement,
      descendants = menu.domContext.descendants,
      isLazy = menu.isLazy;
  /**
   * Hook that creates a keydown event handler that listens
   * to printable keyboard character press
   */

  var onCharacterPress = (0, _hooks.useShortcut)({
    preventDefault: function preventDefault(event) {
      return event.key !== " ";
    }
  });
  var onKeyDown = (0, _utils.createOnKeyDown)({
    onKeyDown: onCharacterPress(function (character) {
      /**
       * Typeahead: Based on current character pressed,
       * find the next item to be selected
       */
      var nextItem = (0, _utils.getNextItemFromSearch)(descendants, character, function (node) {
        var _node$element;

        return ((_node$element = node.element) == null ? void 0 : _node$element.textContent) || "";
      }, descendants[focusedIndex]);

      if (nextItem) {
        var index = descendants.indexOf(nextItem);
        setFocusedIndex(index);
      }
    }),
    keyMap: {
      Escape: onClose,
      ArrowDown: function ArrowDown() {
        var nextIndex = (0, _utils.getNextIndex)(focusedIndex, descendants.length);
        setFocusedIndex(nextIndex);
      },
      ArrowUp: function ArrowUp() {
        var prevIndex = (0, _utils.getPrevIndex)(focusedIndex, descendants.length);
        setFocusedIndex(prevIndex);
      }
    }
  });
  return _extends({}, props, {
    children: !isLazy || isOpen ? props.children : null,
    className: (0, _utils.cx)("chakra-menu__menu-list", props.className),
    ref: (0, _utils.mergeRefs)(menuRef, popper.ref),
    tabIndex: -1,
    role: "menu",
    id: menuId,
    hidden: !isOpen,
    "aria-orientation": "vertical",
    "data-placement": placement,
    style: _extends({}, popper.style, props.style),
    onKeyDown: (0, _utils.callAllHandlers)(props.onKeyDown, onKeyDown)
  });
}
/**
 * React Hook to manage a menu button.
 *
 * The assumption here is that the `useMenu` hook is used
 * in a component higher up the tree, and it's return value
 * is passed as `context` to this hook.
 */


function useMenuButton(props) {
  var menu = useMenuContext();
  var setFocusedIndex = menu.setFocusedIndex,
      onOpen = menu.onOpen,
      isOpen = menu.isOpen,
      onClose = menu.onClose,
      autoSelect = menu.autoSelect,
      menuRef = menu.menuRef,
      descendants = menu.domContext.descendants;
  var openAndFocusMenu = (0, _react.useCallback)(function () {
    onOpen();

    if (menuRef.current) {
      (0, _utils.focus)(menuRef.current);
    }
  }, [onOpen, menuRef]);
  var openAndFocusFirstItem = (0, _react.useCallback)(function () {
    onOpen();
    setFocusedIndex(0);
  }, [onOpen, setFocusedIndex]);
  var openAndFocusLastItem = (0, _react.useCallback)(function () {
    onOpen();
    var lastIndex = descendants.length - 1;
    setFocusedIndex(lastIndex);
  }, [onOpen, setFocusedIndex, descendants]);
  var onClick = (0, _react.useCallback)(function () {
    if (isOpen) {
      onClose();
    } else {
      var action = autoSelect ? openAndFocusFirstItem : openAndFocusMenu;
      action();
    }
  }, [autoSelect, isOpen, onClose, openAndFocusFirstItem, openAndFocusMenu]);
  var onKeyDown = (0, _utils.createOnKeyDown)({
    keyMap: {
      Enter: openAndFocusFirstItem,
      ArrowDown: openAndFocusFirstItem,
      ArrowUp: openAndFocusLastItem
    }
  });
  return _extends({}, props, {
    ref: (0, _utils.mergeRefs)(menu.buttonRef, menu.reference.ref),
    className: (0, _utils.cx)("chakra-menu__menu-button", props.className),
    id: menu.buttonId,
    "data-active": (0, _utils.dataAttr)(menu.isOpen),
    "aria-expanded": menu.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": menu.menuId,
    onClick: (0, _utils.callAllHandlers)(props.onClick, onClick),
    onKeyDown: (0, _utils.callAllHandlers)(props.onKeyDown, onKeyDown)
  });
}

function useMenuItem(props) {
  var onMouseOutProp = props.onMouseOut,
      onClickProp = props.onClick,
      isDisabled = props.isDisabled,
      isFocusable = props.isFocusable,
      htmlProps = _objectWithoutPropertiesLoose(props, ["onMouseOut", "onClick", "isDisabled", "isFocusable"]);

  var menu = useMenuContext();
  var domContext = menu.domContext,
      setFocusedIndex = menu.setFocusedIndex,
      focusedIndex = menu.focusedIndex,
      closeOnSelect = menu.closeOnSelect,
      onClose = menu.onClose,
      menuRef = menu.menuRef;
  var ref = (0, _react.useRef)(null);
  var id = "menuitem-" + (0, _hooks.useId)();
  /**
   * Register the menuitem's node into the domContext
   */

  var index = (0, _descendant.useDescendant)({
    element: ref.current,
    context: domContext,
    disabled: isDisabled,
    focusable: isFocusable
  });
  var onMouseEnter = (0, _react.useCallback)(function () {
    if (isDisabled) return;
    setFocusedIndex(index);
  }, [setFocusedIndex, index, isDisabled]);
  var onMouseMove = (0, _react.useCallback)(function () {
    if (document.activeElement !== ref.current) {
      onMouseEnter();
    }
  }, [onMouseEnter]);
  var onMouseLeave = (0, _react.useCallback)(function () {
    if (isDisabled) return;
    setFocusedIndex(-1);
  }, [setFocusedIndex, isDisabled]);
  var onClick = (0, _react.useCallback)(function (event) {
    onClickProp == null ? void 0 : onClickProp(event);
    /**
     * Close menu and parent menu's if `closeOnSelect` is set to `true`
     */

    if (closeOnSelect) {
      onClose();
    }
  }, [onClose, onClickProp, closeOnSelect]);
  var isFocused = index === focusedIndex;
  var trulyDisabled = isDisabled && !isFocusable;
  (0, _hooks.useUpdateEffect)(function () {
    if (isFocused && !trulyDisabled) {
      if (ref.current) {
        (0, _utils.focus)(ref.current);
      }
    } else {
      if (document.activeElement !== menuRef.current) {
        var _menuRef$current;

        (_menuRef$current = menuRef.current) == null ? void 0 : _menuRef$current.focus();
      }
    }
  }, [isFocused, trulyDisabled, menuRef]);
  var tabbable = (0, _clickable.useClickable)({
    onClick: onClick,
    onMouseEnter: onMouseEnter,
    onMouseMove: onMouseMove,
    onMouseLeave: onMouseLeave,
    ref: ref,
    isDisabled: isDisabled,
    isFocusable: isFocusable
  });
  return _extends({}, htmlProps, tabbable, {
    className: (0, _utils.cx)("chakra-menu__menuitem", htmlProps.className),
    id: id,
    role: "menuitem",
    tabIndex: isFocused ? 0 : -1
  });
}

function useMenuOption(props) {
  var onMouseOut = props.onMouseOut,
      onClick = props.onClick,
      isDisabled = props.isDisabled,
      isFocusable = props.isFocusable,
      _props$type = props.type,
      type = _props$type === void 0 ? "radio" : _props$type,
      isChecked = props.isChecked,
      rest = _objectWithoutPropertiesLoose(props, ["onMouseOut", "onClick", "isDisabled", "isFocusable", "type", "isChecked"]);

  var ownProps = useMenuItem({
    isDisabled: isDisabled,
    isFocusable: isFocusable,
    onClick: onClick
  });
  return _extends({}, rest, ownProps, {
    className: (0, _utils.cx)("chakra-menu__menuitem-option", rest.className),
    role: "menuitem" + type,
    "aria-checked": isChecked
  });
}

function useMenuOptionGroup(props) {
  var children = props.children,
      _props$type2 = props.type,
      type = _props$type2 === void 0 ? "radio" : _props$type2,
      valueProp = props.value,
      defaultValue = props.defaultValue,
      onChange = props.onChange,
      htmlProps = _objectWithoutPropertiesLoose(props, ["children", "type", "value", "defaultValue", "onChange"]);

  var isRadio = type === "radio";
  var fallback = isRadio ? "" : [];

  var _useControllableState = (0, _hooks.useControllableState)({
    defaultValue: defaultValue != null ? defaultValue : fallback,
    value: valueProp,
    onChange: onChange
  }),
      value = _useControllableState[0],
      setValue = _useControllableState[1];

  var handleChange = (0, _react.useCallback)(function (selectedValue) {
    if (type === "radio" && (0, _utils.isString)(value)) {
      setValue(selectedValue);
    }

    if (type === "checkbox" && (0, _utils.isArray)(value)) {
      var nextValue = value.includes(selectedValue) ? (0, _utils.removeItem)(value, selectedValue) : (0, _utils.addItem)(value, selectedValue);
      setValue(nextValue);
    }
  }, [value, setValue, type]);
  var validChildren = (0, _utils.getValidChildren)(children);
  var clones = validChildren.map(function (child) {
    var onClick = function onClick(event) {
      handleChange(child.props.value);
      child.props.onClick == null ? void 0 : child.props.onClick(event);
    };

    var isChecked = type === "radio" ? child.props.value === value : value.includes(child.props.value);
    return /*#__PURE__*/(0, _react.cloneElement)(child, {
      type: type,
      onClick: onClick,
      isChecked: isChecked
    });
  });
  return _extends({}, htmlProps, {
    className: (0, _utils.cx)("chakra-menu__option-group", htmlProps.className),
    children: clones
  });
}

function useMenuState() {
  var _useMenuContext = useMenuContext(),
      isOpen = _useMenuContext.isOpen,
      onClose = _useMenuContext.onClose;

  return {
    isOpen: isOpen,
    onClose: onClose
  };
}
